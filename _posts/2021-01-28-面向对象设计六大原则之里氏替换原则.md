---
layout: post
title:  "里氏替换原则"
categories: 软件架构设计
tags: Spring内功心法
author: Gzw
---
## 里氏替换原则 (Liskov Substitution Principle)

里式替换原则：任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，同时软件功能单位不受到影响，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
里氏替换原则也可以理解为：（1）如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有的程序P在所有的对象o1都代换成o2时，程序P的行为没有发生改变，那么类T2就是类T1的子类。
（2） 所有引用基类的地方必须能够透明的使用其子类对象 。通俗来说:子类可以扩展父类的功能但是不能改变父类原有的功能。

里氏替换原则的问题由来：一个功能P1由类A来完成，但是需要P1功能进行扩展，扩展后的功能为P，P包含原来的功能P1和扩展的功能P2，现在有A类的子类B来完成，子类B在完成扩展功能P2的同时，有可能会导致原有的功能发生错误。  
目前有一个类A，实现两个数相减的功能。
```java
public class A {
    public int func1(int a,int b){
        return  a-b;
    }
}
```
![](https://gitee.com/gzwas/noteimage/raw/master/img/20210128151813.png)
现在要扩展功能两个数相加然后再加上100，由A类的子类B类完成，A类完成了的两数相减功能，B类完成新增的功能
```java
public class B extends A {
    public int func1(int a,int b){
        return a+b;
    }
    public int func2(int a,int b){
        return func1(a,b)+100;
    }
}
```
用子类B替换A类，就会使程序发生错误：
![](https://gitee.com/gzwas/noteimage/raw/master/img/20210128153020.png)
我们发现原来A类的a-b功能，现在出错了，这是因为B类在继承A类后写的方法名无意间和A类的方法名重复了，这就使得在子类B类替换A类后调用A类相减功能时，使得调用了B类的相加功能，导致程序结果出错。  
解决的方法：当使用继承时，遵循里氏替换原则。类B继承类A时，除了添加新的方法之外，尽量不要重写父类的方法，也尽量不要重载父类的方法。【有时候我们可以采用final方式来强制遵循】。  
继承包含了这样一层含义：父类已经实现好的方法，这就是设定了一系列的规范和契约，父类不强制要求子类遵循这一规范和契约，但是当子类对这些方法进行修改后会对整个继承体系造成重大的破坏。里氏替换原则就表示这一层含义。  
再次来理解里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
* 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
* 子类中可以增加自己特有的方法。
* 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。【注意区分重载和重写】
* 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。