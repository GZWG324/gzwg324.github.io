---
layout: post
title:  "原型模式"
categories: 软件架构设计
tags: Spring内功心法
author: Gzw
---

# 原型模式

![](https://gitee.com/gzwas/noteimage/raw/master/img/20210207154904.png)

**原型模式：**原型模式就是克隆，所谓的原型模式就是用原型示实例指定创建对象的种类，并且通过赋值这些原型创建新的对象。

在原型模式中我们可以利用原型对象来指明我们所要创建对象的类型，然后通过复制这个对象的方法来获得与该对象一模一样的对象实例。

**浅拷贝和深拷贝：**

**浅拷贝：**使用一个已知实例对新创建实例的成员变量逐个赋值，这种方式为浅拷贝。

（浅拷贝就是拷贝基本类型即复制基本类型给新对象中的变量，对于引用的类型，浅拷贝只是将对象中引用成员变量当中的对象地址给复制下来即新对象和就对象中引用的成员变量使用的是同一个对象，当引用的对象数据发生改变会影响另一个对象中的成员变量值改变。特殊的引用类型String类型，浅拷贝复制新的值给String，旧对象的值发生改变不会改变新的对象中String的值；这是由于String类型特殊的方式来决定的，当String对象创建好之后，数据就不会发生改变，当使用+等进行字符串拼接修改时，会生成拼接或修改后的新的String类型返回，这就使得修改的String和未修改的String变量当中存储的内存地址值不一样，自然相互之间不会发生影响）。

```java
public class Test1 {
    public static void main(String[] args){
        String str = "001";
        String str2  = str+"002";
        System.out.println(str == str2);//输出为 false
        /**
         * 返回值为false,我们知道 == 运算符判断对象时就是判断前后两个变量的内存地址值是否相同,
         * 这里创建一个字符串变量str引用String对象“001”(String类型的对象可以这样进行创建)，
         * 将str加上了”002“，实现了字符串的拼接，并给了另一个字符串对象str2,通过 == 
         * 我们发现原来的字符串与拼接后的字符串内存地址不同了，这是因为字符串在进行修改时会生成
         * 新的字符串并返回。
         * */
    }
}
```



**深拷贝：**当一个类的构造方法，不仅要复制对象的所有非引用成员变量，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实值。

原型模式主要任务是实现一个接口，这个接口具有一个clone方法可以实现拷贝对象的功能。由于java语言中，JDK已经默认给我们提供了一个Coneable接口，所以我们不需要自己去创建一个接口类了。Coneable是一个标记接口，它并没有任何方法，只有实现了Coneable接口的类在JVM当中才有可能背拷贝。既然Conable接口中没有任何任何方法，那clone()方法是从哪里来的？由于java中所有的类都是Object的子类，所以我们只需要重写来自Object类中的clone()方法就行了。